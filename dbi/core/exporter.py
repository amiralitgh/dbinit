from __future__ import annotations
from pathlib import Path
from datetime import datetime
from typing import Dict, Tuple, List
import numpy as np
from .model import ProjectState

def _fmt(x: float) -> str:
    return f"{x:.12g}"

def _chunk_iter(seq, n):
    for i in range(0, len(seq), n):
        yield seq[i:i+n]

def export_lammps_block(state: ProjectState, out_dir: Path) -> Path:
    out_dir = Path(out_dir); out_dir.mkdir(parents=True, exist_ok=True)
    ts = datetime.now().strftime("%H%M%S")
    out_path = out_dir / f"DBI_Displacements_{ts}.in"

    B = state.breather
    A   = float(B.A); beta= float(B.beta); x0  = float(B.x0); y0  = float(B.y0)
    apply_loc = bool(state.apply_localizing)

    ids_all = state.data.ids.astype(int)
    x_all   = state.data.x; y_all = state.data.y

    buckets: Dict[Tuple[str,str,str], List[int]] = {}
    total_selected = 0

    for gid, grp in sorted(state.groups.items()):
        idx = np.nonzero(state.assignment == gid)[0]
        if idx.size == 0: continue

        ux, uy, uz = grp.direction
        dx0 = x_all[idx] - x0; dy0 = y_all[idx] - y0
        R   = np.sqrt(dx0*dx0 + dy0*dy0)
        amp = (A / np.cosh(beta * R)) if apply_loc else (A * np.ones_like(R))

        dx = amp * ux; dy = amp * uy; dz = amp * uz

        sel_ids = ids_all[idx]; total_selected += sel_ids.size
        for j, atom_id in enumerate(sel_ids):
            k = (_fmt(dx[j]), _fmt(dy[j]), _fmt(dz[j]))
            buckets.setdefault(k, []).append(int(atom_id))

    g1_ids = ids_all[np.nonzero(state.assignment == 1)[0]].tolist()
    g2_ids = ids_all[np.nonzero(state.assignment == 2)[0]].tolist()

    with open(out_path, "w", newline="\n") as f:
        f.write("# Generated by Discrete Breather Init (DBI)\n")
        f.write("# Numeric displacement export with vector bucketing and single temp group\n")
        f.write(f"# Params: A={_fmt(A)} beta={_fmt(beta)} x0={_fmt(x0)} y0={_fmt(y0)} apply_local={int(apply_loc)}\n")
        f.write(f"# Selected atoms total: {total_selected}\n\n")

        f.write("group 1 empty\n")
        f.write("group 2 empty\n")
        if g1_ids:
            for chunk in _chunk_iter(g1_ids, 1000):
                f.write("group 1 id " + " ".join(str(i) for i in chunk) + "\n")
        if g2_ids:
            for chunk in _chunk_iter(g2_ids, 1000):
                f.write("group 2 id " + " ".join(str(i) for i in chunk) + "\n")
        f.write("group breathers union 1 2\n\n")

        f.write("# Using a reusable temporary group\n")
        total_batches = 0; total_atoms_moved = 0

        def key_sort(k):
            dx, dy, dz = (float(k[0]), float(k[1]), float(k[2]))
            return (abs(dx)+abs(dy)+abs(dz), dx, dy, dz)

        for (dxs, dys, dzs) in sorted(buckets.keys(), key=key_sort):
            id_list = buckets[(dxs, dys, dzs)]
            for chunk in _chunk_iter(id_list, 2000):
                f.write("group __tmp__ id " + " ".join(str(i) for i in chunk) + "\n")
            f.write(f"displace_atoms __tmp__ move {dxs} {dys} {dzs}\n")
            f.write("group __tmp__ delete\n\n")
            total_batches += 1
            total_atoms_moved += len(id_list)

        f.write(f"# Finished: {total_atoms_moved} atoms moved in {total_batches} batches.\n")
        f.write("# End\n")

    return out_path

def export_selected_ids(state: ProjectState, out_dir: Path, scope: str = "all", active_gid: int = 0) -> Path:
    out_dir = Path(out_dir); out_dir.mkdir(parents=True, exist_ok=True)
    ts = datetime.now().strftime("%H%M%S")
    if scope == "active" and active_gid:
        fname = f"DBI_IDs_active_g{active_gid}_{ts}.txt"
        idx = np.nonzero(state.assignment == active_gid)[0]
    else:
        fname = f"DBI_IDs_all_selected_{ts}.txt"
        idx = np.nonzero(state.assignment != 0)[0]

    ids = state.data.ids[idx].astype(int).tolist()
    p = out_dir / fname
    with open(p, "w", encoding="utf-8", newline="\n") as f:
        f.write("# Selected atom IDs\n")
        if scope == "active" and active_gid:
            f.write(f"# Scope: active group {active_gid}\n")
        else:
            f.write("# Scope: all assigned groups\n")
        for i in range(0, len(ids), 1000):
            f.write(" ".join(str(x) for x in ids[i:i+1000]) + "\n")
    return p
